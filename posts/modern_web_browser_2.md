---
title: "모던 웹 브라우저 살펴보기 _ 2탄"
date: "2023-03-06"
description: "Chrome Developers Blog: Inside look at modern web browser (part 2)"
tags: ["web", "browser", "cs"]
thumbnail: "thumbnail.png"
---

해당 글에서는 웹 사이트를 표시하기 위해 각 프로세스와 스레드가 통신하는 방법에 대하여 설명한다.

브라우저에서 URL을 입력하면 브라우저는 인터넷에서 데이터를 가져와 페이지를 표시한다. 사용자가 사이트를 요청하고 브라우저가 페이지를 렌더링 할 준비를 하는 과정인 네비게이션에 대해 알아보자.

## 브라우저 프로세스로 시작

---

탭 외부의 모든 것은 **브라우저 프로세스**에서 처리된다.
브라우저의 버튼이나 인풋 등을 그리는 UI 스레드, 데이터를 수신하기 위한 네트워크 스레드, 파일에 대한 액세스를 제공하는 스토리지 스레드 등이 브라우저 프로세스에 포함된다. 주소창에 URL을 입력하면 프로세스의 UI 스레드에서 입력을 처리한다.

## 작동 과정

---

### 1. 입력 처리

주소창에 값이 입력되면 UI 스레드에서는 가장 먼저 '검색어인가? URL인가?'를 판단하는 작업을 한다.
Chrome에서 주소창은 검색 필드이기도 하기 때문이다. 이를 바탕으로 유저를 검색 엔진으로 이동시킬지, 요청한 사이트로 이동시킬지 결정한다.

### 2. 네비게이션 시작

사용자가 Enter를 누르면 UI 스레드가 네트워크 호출을 시작하여 데이터와 콘텐츠를 가져온다.
네트워크 스레드는 DNS를 조회하고, 요청에 대한 TLS 연결 설정 등의 작업을 거친다.
이 때, 네트워크 스레드에서 서버 redirection 헤더를 수신할 수 있다. 그러면 네트워크 스레드는 서버가 UI 스레드와 통신하고, UI 스레드에서 서버가 redirection을 요청한다. 그렇게 다음 URL에 대한 요청이 시작된다.

DNS(Domain Name System)
IP 주소를 도메인 이름으로, 또는 그 반대로 변환해주는 네트워크 시스템이다. 모든 웹사이트의 네트워크 주소를 기억하기 힘들기 때문에 각 IP에 이름을 부여하여 이해하기 쉽도록 한다.

TLS(Transport Layer Security)는 인터넷에서의 정보를 암호화하여 송/수신하는 프로토콜이다. SSL의 향상된 버전이다. SSL(Secure Sockets Layer)는 웹사이트와 브라우저 사이에 전송되는 데이터를 암호화하여 인터넷 연결으르 보호하는 표준 기술이다. 제3자가 개인의 데이터나 금융 데이터 등 중요한 정보를 열람하거나 도난하는 것을 방지한다.

### 3. Response 읽기

페이로드가 들어오면 네트워크 스레드는 스트림의 처음 몇 바이트를 확인한다. Response의 Content-Type 헤더가 데이터 유형을 나타내지만, 이 값이 잘못되었을 가능성이 있으므로 MIME type sniffing이 실행된다.

MIME은 다목적 인터넷 메일 확장으로, 전자 우편 데이터의 형식을 정의한 표준 포맷이다. 현재는 HTTP 통신에서 데이터 형식을 식별하기 위해 사용된다. MIME sniffing은 MIME 타입이 올바르지 않을 때, 리소스를 보고 올바른 타입을 추측하는 것을 의미한다.

!["safe browsing"](/images/posts/modern_web_browser_2/safe_browsing.png)

Response 타입이 HTML 파일인 경우에는 렌더러 프로세스에 데이터를 전달하지만, zip 파일 등 다른 형식의 파일인 경우에는 다운로드에 대한 요청을 먼저 처리해야 하므로 다운로드 관리자에 데이터를 전달한다.

네트워크 스레드에서는 세이프 브라우징도 이루어진다. 도메인과 response 데이터가 악성 사이트인 경우 네트워크 스레드가 경고 페이지를 표시한다. 또한, 민감한 사이트 간 데이터가 렌더러 프로세스에 전달되지 않도록 CORB(Cross Origin Read Blocking) 검사를 실행한다.

### 4. 렌더러 프로세스 찾기

모든 검사를 완료하고 네트워크 스레드가 브라우저가 요청한 사이트로 이동할 수 있다고 판단하면, 네트워크 스레드는 UI 스레드에게 데이터가 준비되었음을 알린다. 그러면 UI 스레드에서는 웹 페이지 렌더링을 실행할 렌더러 프로세스를 찾는다.

네트워크 요청이 response를 받기까지 오랜 시간이 소요될 수 있으므로, 프로세스의 속도를 높이기 위한 최적화를 적용한다. UI 스레드는 2단계에서 네트워크 스레드에게 URL 요청을 보내면서 탐색할 사이트를 미리 알고 있기 때문에, 네트워크 요청과 병렬로 작업하여 렌더러 프로세스를 사전에 찾기 시작한다. 이렇게 되면 렌더러 프로세스는 네트워크 프로세스가 데이터를 수신했을 때 미리 대기 상태가 되어있을 수 있으다. 하지만 탐색이 cross-site로 redirect 되는 경우에는 다른 프로세스를 사용해야 할 수도 있다.

### 5. 탐색 시작

데이터와 렌더러 프로세스가 준비된 후, 탐색을 시작하기 위해 IPC가 브라우저 프로세스 -> 렌더러 프로세스로 전송된다. 그리고 렌더러 프로세스가 HTML 데이터를 계속 수신할 수 있도록 데이터 스트림을 전달한다. 참고로 데이터 스트림은 연결 지향형 통신에서 정보를 전송하거나 전송된 정보를 수집할 때 사용하는 디지털 방식으로, 암호화된 신호의 흐름이다.
렌더러 프로세스에서 탐색이 시작되었다는 신호를 브라우저 프로세스에서 받으면 탐색이 완료되고 문서 로드 단계가 시작된다.

이 때, 주소창이 업데이트 되고 새 페이지의 정보가 사이트에 반영된다. 탭에서 사용하는 세선 기록이 업데이트되어 앞/뒤 버튼이 이동할 경로에도 반영되며, 탭이나 창을 닫을 때 탭/세션 복원을 쉽게 하기 위해 세션 기록이 디스크에 저장된다.

!["ipc browser process to renderer process"](/images/posts/modern_web_browser_2/ipc.png)

### 추가 단계: 초기 로드 완료

탐색이 적용되면 렌더러 프로세스는 리소스를 계속 로딩하면서 페이지를 렌더링 한다. 렌더러 프로세스가 렌더링 작업을 마치면(`onload` 페이지의 모든 페이지에서 모든 이벤트가 발생하고 실행이 완료된 후), IPC를 브라우저 프로세스로 다시 전달한다. 이 시점에 UI 스레드는 탭에 있는 로딩 스피너를 멈춘다. 클라이언트 측 자바스크립트는 여전히 추가적인 리소스를 로드하고 새로운 뷰를 렌더링 할 수 있기 때문에 완료되었다고 할 수 있다.

!["ipc renderer process to browser process"](/images/posts/modern_web_browser_2/ipc2.png)

## 다른 사이트로 이동하기

---

만약 유저가 다른 URL 주소를 주소창에 입력하면 어떻게 될까? 앞에서 설명한 단계와 똑같은 단계를 밟아 새로운 사이트로 이동할 것이다. 하지만 작업들을 시작하기 전에, 현재 렌더링 된 사이트에서 `beforeunload` 이벤트를 실행해야 하는지 확인하는 작업을 거쳐야 한다.
`beforeunload`는 다른 사이트로 이동하거나 탭을 닫으려고 할 때 "이 사이트를 떠나시겠습니까?" 메시지를 표시한다. 우리가 작성한 자바스크립트 코드를 포함한 탭에 포함된 모든 것이 렌더러 프로세스에 의해 제어되기 때문에, 브라우저 프로세스는 새로운 탐색 요청이 들어왔을 때 현재 렌더러 프로세스를 확인해야 한다.

`beforeunload` 핸들러를 사용하면 네비게이션을 시작하기 전에 핸들러를 실행하는 시간으로 인해 더 많은 대기시간이 발생할 수 있음을 주의해야 한다. 따라서 사이트를 떠나면 페이지에 입력한 데이터가 손실되는 등 필요한 경우에만 추가하도록 하자.

탐색이 브라우저 프로세스가 아니라 렌더러 프로세스에서 시작되는 경우도 있다. 예를 들어 사용자가 링크 클릭을 통해 들어오거나, 클라이언트 측에서 `window.location` 등의 자바스크립트 실행을 통해 들어온 경우이다. 이러한 경우 `beforeunload` 핸들러는 렌더러 프로세스가 확인하며, 브라우저 프로세스가 거쳤던 탐색 시작단계와 동일한 프로세스를 거친다. 유일한 차이점은 탐색 요청의 시작점이 다르다는 것 뿐이다.

다른 사이트로 이동하는 새 탐색 과정이 실행되면, 별도의 렌더러 프로세스가 호출되어 새 탐색을 처리하고 현재 렌더러 프로세스는 `unload` 이벤트를 처리한다.

## Service Worker

---

최근 탐색 과정에서 변경된 점은 서비스 워커가 추가되었다는 것이다.
서비스 워커는 애플리케이션 코드에 네트워크 프록시를 추가하는 방법으로, 웹 개발자들이 로컬에서 캐싱할 항목과 네트워크에서 새로운 데이터를 가져올 시기를 더 잘 제어할 수 있도록 도와준다. 서비스 워커가 캐시에서 페이지를 로드하도록 설정되면 네트워크에서 데이터를 요청할 필요가 없다.

우리가 기억해야 할 점은 서비스 워커가 렌더러 프로세스에서 실행되는 자바스크립트 코드라는 것이다. 그러면 탐색 요청이 들어왔을 때 브라우저 프로세스는 사이트가 서비스 워크를 가지고 있는지 어떻게 알 수 있을까?

서비스 워커가 등록되면 서비스 워커의 범위를 계속 참조한다. 탐색이 일어나면 네트워크 스레드는 등록된 서비스 워커의 범위 내에서 도메인을 체크한다. 서비스 워크가 특정 URL에 등록되어 있으면 UI 스레드는 서비스 워커 코드를 실행시키기 위해서 렌더러 프로세스를 찾는다. 서비스 워커는 캐시로부터 데이터를 로드할 것이고, 네트워크에서 데이터를 요청할 필요가 없어지거나 새로운 리소스를 요청할 수 있다.

!["service worker process"](/images/posts/modern_web_browser_2/service_worker.png)

## Navigation Preload

---

브라우저 프로세스와 렌더러 프로세스 간에 지속적인 왕복으로 인해, 서비스 워커가 네트워크에서 데이터를 요청할 때 지연이 발생할 수 있다. Navigation Preload는 서비스 워커가 시작되었을 때 병렬로 리소스를 로딩함으로써 속도를 높히는 방법이다.
요청을 헤더로 표시하여 서버가 요청에 대해 또 다른 컨텐츠를 보낼 수 있도록 한다.
예를 들어, 전체 document 대신에 업데이트 된 데이터만 받는 것이다.
