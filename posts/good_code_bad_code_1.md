---
title: "📚 Good Code, Bad Code: Chapter 1,2,3"
date: "2023-04-26"
description: "Good Code, Bad Code 도서 스터디 후 요약글"
tags: ["study"]
thumbnail: "thumbnail.jpg"
---

# [ 1장 ] 코드 품질

---

고품질의 코드는 요구사항을 완벽하게 충족하며, 요구사항 변화에도 추가 작업에 많은 비용이 들지 않으며, 오류가 발생했으르 때 시스템이 빠르게 복구되거나 부분적으로 작동한다. 또한, 예상되지 않은 상황에서도 데이터 손상없이 작동하므로 신뢰할 수 있는 코드이다. 좋은 소프트웨어를 만들기 위해 좋은 코드가 중요한 이유는, 결국 소프트웨어가 하는 모든 일은 누군가가 요구사항을 실현하기 위해 작성한 코드로 인하여 발생하는 것이기 때문이다. 좋은 소프트웨어인지 아닌지는 코드를 작성할 때 고민하는 사소한 고민들과 결정이 모여서 이루어지는 것이다.

## 코드는 어떻게 소프트웨어가 되는가?

작성한 코드가 의도한 대로 작동하는지 확신하기 위한 과정을 **소프트웨어 개발 및 배포 프로세스**라고 한다.
코드로부터 production 환경에 배포되기 까지의 과정에는 회사와 팀에 따라 조금씩 다르며, 자동화하는 수준도 다르다. 따라서 SW 개발 및 배포 프로세스는 방대하고, 이와 관련한 다양한 프레임워크나 접근 방식이 존재한다.

## 코드 품질의 목표

**소프트웨어가 잘 구축되는 것**이 코드 품질의 목적이다.
달성하려는 것이 무엇인지 판단하여, 이를 달성하는데 도움이 되면 높은 품질의 코드이고 방해된다면 낮은 코드이다.
코드는 작동해야 하며 동시에 변경사항이 있다고 해서 기존의 작동이 멈추면 안되고, 이미 존재하는 기능을 반복해서 구현해서는 안된다.

극단적 예시로 A는 앞으로의 많은 요구사항 변화를 모두 지원하기 위한 코드를 설계하다가 미래 예측에 너무 많은 시간을 보내 경쟁 서비스가 먼저 시장에 나오게 되었고, B는 요구사항 변화를 완전히 무시하고 설계하였다가 변경 사항으로 인해 모든 코드를 버리고 다시 짜는 상황이 놓였다.
두 상황 모두 효과적인 SW 제작 방식이 아니며, 이 두 극단의 중간에서 접근법을 찾아야 한다.

## 코드 품질의 핵심 요소

읽기 쉬어야 한다 / 예측 가능해야 한다 / 오용하기 어렵게 만들어야 한다 / 모듈화 해야한다 / 재사용 가능하고 일반화할 수 있어야 한다 / 테스트 용이한 코드를 작성하고 제대로 테스트 해야한다

모둘화된 시스템의 주요 특징은 **인터페이스가 잘 정의되어 서로 다른 구성 요소간 상호작용 하는 지점이 최소화** 된다는 것이다.

재사용성(reusability)은 문제를 해결하기 위한 무언가가 여러가지 다른 상황에서도 사용될 수 있음을 의미한다.(문제는 동일하나 상황은 다르다) 일반화성(generalizability)는 개념적으로는 유사하지만 서로 미묘하게 다른 문제들을 해결할 수 있음을 의미한다. 모듈화된 코드는 더 높은 재사용성과 일반화성을 갖는다.

### 테스트

- 단위(unit) 테스트: 개별 함수나 클래스와 같은 작은 단위의 코드를 테스트
- 통합(integration) 테스트: 구성 요소와 하위 시스템을 연결하는 과정을 통합이라고 함. 구성 요소가 제대로 실행되는지 확인
- 종단간(E2E) 테스트: 전체 소프트웨어 시스템의 처음부터 끝까지 흐름(워크 플로우)을 테스트

테스트 용이성은 테스트 대상이 되는 실제 코드를 가리키며, 해당 코드가 얼마나 테스트하기 적합한지를 나타낸다. 모듈화된 코드는 테스트 용이성이 더 좋다. 테스트 용이성을 확인하기 위해 코드를 작성하면서 '어떻게 테스트할 것인가?'를 자문하는 것이 좋다.

## 고품질 코드 작성은 일정을 지연시키는가?

단기적으로는 더 오랜 시간이 걸릴 수 있어도, 중장기적으로는 개발 시간을 단축해준다. '서두르지 않으면 더 빠르다.'

# [ 2장 ] 추상화 계층

---

코드 작성의 목적은 `문제 해결`이다. 문제를 어떻게 해결하는가도 중요하지만, 코드를 어떻게 구성하는지가 중요한 이유는 코드 구성 방법이 코드 품질의 기본적인 면이기 때문이다. 코드를 잘 구성한다는 것은 추상화 계층을 간결하게 만드는 것이다.

## Null값 및 의사코드 규약

Null값을 핸들링하기 까다로운 이유는 값이 널일 수 있거나 널이면 안되는 경우가 명백하지 않기 때문이다. 최근 널 안전성 또는 보이드 안전성을 위한 방법이 발전되어, nullish한 변수나 리턴값을 그에 맞게 표시하고 컴파일러는 널값 여부를 확인한다. 만약 널 안전성을 지원하지 않는 언어라면 옵셔널 타입을 사용한다.

```js
Optional<Element> getFifthElement(List<Element> elements) {
    if(elements.size() < 5) {
        return Optional.empty()
    }
    return Optional.of(elements[4])
}
```

## 추상화 계층을 만드는 이유

어떠한 문제를 하위 문제로 계속 나누어 내려가면서 추상화 계층을 들면, 동일 층 내에서는 쉽게 이해할 수 있는 몇 개의 개념만을 다루기 때문에 코드가 복잡해 보이지 않을 것이다. 즉, 추상화 계층을 나눔으로써 필요한 부분 외 다른 계층의 개념이나 코드 구현에 대해서는 알 필요가 없어진다.

### 추상화 계층 및 코드 품질의 핵심 요소

- 가독성: 뚜렷하고 가독성 좋은 추상화 계층은 개발자가 한 번에 다뤄야 할 개념이 적어짐을 의미
- 모듈화: 다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내부에서만 변경하기 용이
- 재사용성 및 일반화성: 적절히 추상화되면, 다른 상황에서 유용하게 일반화될 가능성이 높음
- 테스트 용이성: 각 하위 문제에 대한 테스트 코드를 구현하는 것이 쉬워짐

## 코드의 계층

추상화 계층을 만드는 방법은 코드를 서로 다른 단위(함수, 클래스, 인터페이스, 패키지, 모듈 등)로 분할하여 단위 간 의존 관계를 나타내는 그래프를 만드는 것이다.

### API 및 구현 세부 사항

코드를 작성할 때는 다음 두 가지를 고려해야 한다.

1. 코드를 호출할 때 볼 수 있는 내용

- public class, interface 및 함수
- 이름, 입력 매개변수, 리턴 타입
- 코드 호출시 올바르게 사용하기 위해 알아야 하는 추가적인 정보 (ex. 호출 순서)

2. 코드를 호출할 때 볼 수 없는 내용

- 구현 세부 사항

API는 서비스를 사용할 때 알아야 할 개념을 형식화하고, 서비스의 모든 구현 세부 사항은 API 뒤에 감춘다. 어떤 코드를 호출하는 측에서 그 코드에 대해 알고 있는 사항을 공개 API라고 할 수 있다. 따라서 API 관점에서 생각하면 추상화 계층을 명확하게 만드는데 도움이 된다.

### 함수

하나의 함수는 단일 업무를 수행하도록 구현하면 코드의 가독성과 재사용성이 높아진다. 함수를 `한 문장으로 표현하기` 어렵게 구현했다면 로직의 일부를 헬퍼 함수로 분리하는 것을 고려해보아야 한다.

### 클래스

단일 클래스의 이상적인 크기에 대한 다양한 이론이다.

1. 줄 수: '한 클래스는 코드 300줄을 넘지 않아야 한다' 같은 줄 수에 대한 제한을 두는 것

2.응집력: 한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지 보여 주는 척도

3. 관심사의 분리: 시스템의 각각 별개의 문제를 다루는 개발 구성 요소로 분리되어 설계되어야 함

응집력과 관심사 분리에 대해 생각할 때는 관련된 여러 사항을 하나의 사항으로 간주하는 것을 어느 수준에서 해야 유용할지 결정해야 하는데, 이는 사람마다 매우 주관적이기 때문에 어려운 일이다. 대신, 기존 코드를 수정할 때 클래스가 너무 커지는 것이 아닌지 항상 주의해야 한다.

### 인터페이스

계층 사이를 뚜렷하게 구분하면서 구현 세부 사항이 노출되지 않도록 하기에 좋은 방법 중 하나는 어떤 함수를 외부로 노출할 것인지 인터페이스를 통해 결정한 다음, 인터페이스에 정의된 대로 클래스가 해당 계층에 대한 코드를 구현하는 것이다.
상위 클래스를 인터페이스로 추출하고, 해당 클래스의 하위 문제를 해결하기 위한 접근 방식을 서로 다른 클래스로 구현하는 것이다.

인터페이스를 지정하면 어떤 것이 공개된 API인지 명확하게 판단하라 수 있으며, 테스트에 용이하고 동일 클래스로 두 가지 하위 문제를 해결할 수 있다. 따라서 인터페이스가 하나만 있더라도 명시하는 것을 권장한다.

### 층이 너무 얇아질 때

코드를 별개의 계층으로 세분화하면 import문이 늘어나고, 로직 이해를 위해 파일이나 클래스를 따라가며 열어보고 이해해야 하므로 많은 노력이 필요하다는 단점이 있다. 따라서 과다한 코드의 분할로 인해 오히려 단점에 쏟는 비용이 더 높지 않도록 적당선에서 나누어야 한다.

## 마이크로 서비스는 어떤가?

마이크로서비스는 각 문제에 대한 코드가 단일 프로그램으로 컴파일 되는 라이브러리 정도의 수준이 아닌, 독립적으로 실행되는 서비스로 배포된다. 즉, 시스템이 여러 개의 소규모 프로그램으로 분할되어 특정 작업만 전문적으로 수행한다.

마이크로서비스 자체만으로 이미 추상화가 된 것이 사실이지만, 그 내부에서도 적절한 추상화 계층을 고려해야 하는 것은 여전히 중요한 사실이다.
